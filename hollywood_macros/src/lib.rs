#![deny(missing_docs)]

//! Convenience macros for the Hollywood actor framework.

extern crate proc_macro;

use convert_case::{Case, Casing};
use proc_macro::TokenStream;
use quote::quote;
use syn::{
    parse::Parse, parse::ParseStream, parse_macro_input, Error, Fields, Ident, Item, ItemEnum,
    ItemStruct, Path, PathArguments, Result, Token, Type, TypePath,
};

/// Documentation is in the hollywood crate.
#[proc_macro_attribute]
pub fn actor_outputs(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(item as ItemStruct);

    let struct_name = &ast.ident;
    let fields = match &ast.fields {
        Fields::Named(fields_named) => &fields_named.named,
        _ => panic!("`generate_outputs_trait` can only be used with structs with named fields"),
    };

    let output_assignments = fields.iter().map(|field| {
        let field_name = &field.ident;
        if let Some(inner_ty) = is_output_type(&field.ty) {
            // if the field type is OutboundChannel<T>, use OutboundChannel::<T>
            quote! {
                #field_name: OutboundChannel::<#inner_ty>::new(
                    context,
                    stringify!(#field_name).to_owned(),
                    actor_name,
                )
            }
        } else {
            panic!("field type must be OutboundChannel<T>.");
        }
    });

    let output_extract = fields.iter().map(|field| {
        let field_name = &field.ident;

        quote! {
            #field_name: self.#field_name.extract()
        }
    });

    let output_act = fields.iter().map(|field| {
        let field_name = &field.ident;

        quote! {
            self.#field_name.activate();
        }
    });

    let gen = quote! {
        #ast

        impl OutboundHub for #struct_name {
            fn from_context_and_parent(context: &mut Context, actor_name: &str) -> Self {
                Self {
                    #(#output_assignments),*
                }
            }
        }

        impl Morph for #struct_name {
            fn extract(&mut self) -> Self {
                Self {
                    #(#output_extract),*
                }
            }

            fn activate(&mut self) {
                #(#output_act)*
            }
        }

    };

    gen.into()
}

// This function checks if the field's type is OutboundChannel<T> and return T if it is
fn is_output_type(ty: &Type) -> Option<&Type> {
    if let Type::Path(TypePath {
        path: Path { segments, .. },
        ..
    }) = ty
    {
        if segments.len() == 1 && segments[0].ident == "OutboundChannel" {
            if let PathArguments::AngleBracketed(args) = &segments[0].arguments {
                if args.args.len() == 1 {
                    if let syn::GenericArgument::Type(inner_ty) = args.args.first().unwrap() {
                        return Some(inner_ty);
                    }
                }
            }
        }
    }
    None
}

/// Documentation is in the hollywood crate.
#[proc_macro_attribute]
pub fn actor_inputs(args: TokenStream, inbound: TokenStream) -> TokenStream {
    let args = parse_macro_input!(args as ActorInbound);
    let ast = parse_macro_input!(inbound as ItemEnum);

    let name = &ast.ident;
    let fields = &ast.variants;

    let struct_name = &args.struct_name;
    let prop_type = &args.prop_type;
    let state_type = &args.state_type;
    let output_type = &args.output_type;
    let request_type = &args.request_type;

    let inbound = fields.iter().map(|variant| {
        let variant_name = variant.ident.clone();
        let snake_case_variant_name_str = variant_name.to_string().to_case(Case::Snake);
        let snake_case_variant_name = Ident::new(&snake_case_variant_name_str, variant_name.span());
        let field_type = if let Fields::Unnamed(fields_unnamed) = &variant.fields {
            &fields_unnamed.unnamed[0].ty
        } else {
            panic!("Enum variants must be tuples");
        };

        let msg = format!(
            "`{}` channel field - autogenerated by the [actor_inputs] macro.",
            variant_name
        );
        quote! {
            #[doc = #msg]
            pub  #snake_case_variant_name: InboundChannel<#field_type, #name>
        }
    });

    let match_arm = fields.iter().map(|variant| {
        let variant_name = &variant.ident;
        if let Fields::Unnamed(fields_unnamed) = &variant.fields {
            &fields_unnamed.unnamed[0].ty
        } else {
            panic!("Enum variants must be tuples");
        };

        quote! {
            #name::#variant_name(msg) => {
                stringify!(#variant_name).to_string()
            }
        }
    });

    let from_builder_inbounds = fields.iter().map(|variant| {
        let variant_name = &variant.ident;
        let snake_case_variant_name = variant.ident.clone().to_string().to_case(Case::Snake);
        let snake_case_variant_name = Ident::new(&snake_case_variant_name, variant_name.span());
        let field_type = if let Fields::Unnamed(fields_unnamed) = &variant.fields {
            &fields_unnamed.unnamed[0].ty
        } else {
            panic!("Enum variants must be tuples");
        };

        quote! {
            let #snake_case_variant_name = InboundChannel::<#field_type, #name>::new(
                &mut builder.context,
                actor_name.clone(),
                &builder.sender,
                #name::#variant_name(Default::default()).inbound_channel(),
            );
            builder
                .forward
                .insert(#snake_case_variant_name.name.clone(), Box::new(#snake_case_variant_name.clone()));
        }
    });

    let from_builder_init = fields.iter().map(|variant| {
        let variant_name = variant.ident.clone();
        let snake_case_variant_name = variant_name.to_string().to_case(Case::Snake);
        let snake_case_variant_name = Ident::new(&snake_case_variant_name, variant_name.span());

        quote! {
            #snake_case_variant_name,
        }
    });

    let gen = quote! {
        #ast

        /// Auto-generated inbound hub for actor.
        pub struct #struct_name {
            #(#inbound),*
        }

        impl InboundMessage for #name {
            type Prop = #prop_type;
            type State = #state_type;
            type OutboundHub = #output_type;
            type RequestHub = #request_type;

            fn inbound_channel(&self) -> String {
                match self {
                   #(#match_arm),*
                }
            }
        }

        impl InboundHub<#prop_type, #state_type, #output_type, #request_type,#name> for #struct_name {

            fn from_builder(builder: &mut ActorBuilder<#prop_type, #state_type, #output_type,#request_type, #name>,
                            actor_name: &str) -> Self {
                #(#from_builder_inbounds)*

                #struct_name {
                    #(#from_builder_init)*
                }
            }
        }

    };

    gen.into()
}

struct ActorArgs {
    message_type: Ident,
}

impl Parse for ActorArgs {
    fn parse(inbound_hub: ParseStream) -> Result<Self> {
        let message_type: Ident = inbound_hub.parse()?;
        Ok(ActorArgs { message_type })
    }
}

/// Documentation is in the hollywood crate.
#[proc_macro_attribute]
pub fn actor(attr: TokenStream, item: TokenStream) -> TokenStream {
    // parse inbound
    let ActorArgs { message_type } = parse_macro_input!(attr as ActorArgs);
    let inbound: Item = parse_macro_input!(item);
    let inbound_clone = inbound.clone();

    // Get actor name from the item
    let actor_name = match inbound {
        Item::Type(item) => item.ident,
        _ => panic!("`actor` attribute can only be used with type aliases"),
    };

    let mut inbound_clone = inbound_clone.clone();
    let mut attrs = Vec::new();
    if let Item::Type(item_type) = &mut inbound_clone {
        attrs.append(&mut item_type.attrs);
        // ...
    }

    let mut maybe_prop = None;
    let mut maybe_inbounds = None;
    let mut maybe_state = None;
    let mut maybe_outputs = None;
    let mut maybe_requests = None;

    if let Item::Type(item_type) = inbound_clone {
        if let Type::Path(type_path) = *item_type.ty {
            if type_path.path.segments.last().unwrap().ident != "Actor" {
                return Error::new_spanned(&type_path, "Expected Actor<...>")
                    .to_compile_error()
                    .into();
            }
            for segment in type_path.path.segments {
                if let PathArguments::AngleBracketed(angle_bracketed_args) = segment.arguments {
                    if angle_bracketed_args.args.len() != 5 {
                        return Error::new_spanned(
                            &angle_bracketed_args,
                            "Expected 5 type arguments: Actor<PROP, INBOUNDS, STATE, OUTBOUNDS, REQUESTS>",
                        )
                        .to_compile_error()
                        .into();
                    }
                    maybe_prop = Some(angle_bracketed_args.args[0].clone());
                    maybe_inbounds = Some(angle_bracketed_args.args[1].clone());
                    maybe_state = Some(angle_bracketed_args.args[2].clone());
                    maybe_outputs = Some(angle_bracketed_args.args[3].clone());
                    maybe_requests = Some(angle_bracketed_args.args[4].clone());
                }
            }
        } else {
            return Error::new_spanned(&item_type.ty, "Expected a type path")
                .to_compile_error()
                .into();
        }
    } else {
        panic!("`actor` attribute can only be used with type aliases");
    }

    let prop = maybe_prop.unwrap();
    let inbound = maybe_inbounds.unwrap();
    let state_type = maybe_state.unwrap();
    let out = maybe_outputs.unwrap();
    let requests = maybe_requests.unwrap();

    let runner_type = quote! { DefaultRunner<#prop, #inbound, #state_type,  #out, #requests> };

    let gen = quote! {

        ///
        #( #attrs )*
        pub type #actor_name = Actor<#prop, #inbound, #state_type, #out, #requests>;

        impl FromPropState<#prop, #inbound, #state_type, #out, #message_type, #requests, #runner_type>
            for #actor_name
        {
            fn name_hint(prop: &#prop) -> String {
                stringify!(#actor_name).to_owned()
            }
        }
    };

    gen.into()
}

struct ActorInbound {
    struct_name: Ident,
    prop_type: Ident,
    state_type: Ident,
    output_type: Ident,
    request_type: Ident,
}

impl Parse for ActorInbound {
    fn parse(inbound: ParseStream) -> Result<Self> {
        let struct_name: Ident = inbound.parse()?;
        let _: Token![,] = inbound.parse()?;
        let content;
        syn::braced!(content in inbound);
        let prop_type: Ident = content.parse()?;
        let _: Token![,] = content.parse()?;
        let state_type: Ident = content.parse()?;
        let _: Token![,] = content.parse()?;
        let output_type: Ident = content.parse()?;
        let _: Token![,] = content.parse()?;
        let request_type: Ident = content.parse()?;
        Ok(ActorInbound {
            struct_name,
            prop_type,
            state_type,
            output_type,
            request_type
        })
    }
}
